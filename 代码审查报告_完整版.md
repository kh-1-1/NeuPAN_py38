# NeuPAN-py38 å®Œæ•´ä»£ç å®¡æŸ¥æŠ¥å‘Š

> **å®¡æŸ¥æ—¥æœŸ**: 2025-10-23  
> **å®¡æŸ¥èŒƒå›´**: å…¨éƒ¨æ ¸å¿ƒæ¨¡å—  
> **ä»£ç è¡Œæ•°**: ~3500+ è¡Œ  
> **å®¡æŸ¥æ–¹æ³•**: å®Œæ•´ä»£ç é˜…è¯» + é™æ€åˆ†æ

---

## ğŸ“‹ ç›®å½•

1. [ä¸¥é‡é—®é¢˜ï¼ˆé«˜ä¼˜å…ˆçº§ï¼‰](#ä¸¥é‡é—®é¢˜)
2. [åŠŸèƒ½æ€§Bugï¼ˆä¸­ä¼˜å…ˆçº§ï¼‰](#åŠŸèƒ½æ€§bug)
3. [ä»£ç è´¨é‡é—®é¢˜](#ä»£ç è´¨é‡é—®é¢˜)
4. [ä¼˜åŒ–å»ºè®®](#ä¼˜åŒ–å»ºè®®)
5. [æ€»ç»“ä¸å»ºè®®](#æ€»ç»“ä¸å»ºè®®)

---

## ğŸ”´ ä¸¥é‡é—®é¢˜ï¼ˆé«˜ä¼˜å…ˆçº§ï¼‰

### 1. é™¤é›¶é”™è¯¯ - Ackermann è½¬å‘æ¨¡å‹

**ä½ç½®**: `neupan/robot/robot.py:265`  
**ä¸¥é‡ç¨‹åº¦**: ğŸ”´ **æé«˜**  
**é—®é¢˜ç±»å‹**: æ½œåœ¨å´©æºƒ

**é—®é¢˜ä»£ç **:
```python
B = torch.Tensor([ [cos(phi)*dt, 0], [sin(phi)*dt, 0], 
                [ tan(psi)*dt / L, v*dt/(L * (cos(psi))**2 ) ] ])
```

**é—®é¢˜åˆ†æ**:
- å½“è½¬å‘è§’ `psi` æ¥è¿‘ Â±Ï€/2 æ—¶ï¼Œ`cos(psi)` â†’ 0
- `1/(cos(psi)**2)` â†’ âˆï¼Œå¯¼è‡´æ•°å€¼æº¢å‡º
- è™½ç„¶ `robot.py:64-66` é™åˆ¶äº† `max_speed[1] = 1.57`ï¼Œä½†è¿™åªæ˜¯è­¦å‘Šï¼Œä¸æ˜¯ç¡¬çº¦æŸ
- åœ¨ä¼˜åŒ–è¿‡ç¨‹ä¸­ï¼Œ`psi` ä»å¯èƒ½è¶…å‡ºèŒƒå›´

**å½±å“èŒƒå›´**:
- Ackermann æœºå™¨äººåœ¨å¤§è½¬å‘è§’æ—¶å´©æºƒ
- äº§ç”Ÿ NaN/Inf ä¼ æ’­åˆ°æ•´ä¸ªä¼˜åŒ–é—®é¢˜
- å¯¼è‡´ NRMP æ±‚è§£å™¨å¤±è´¥

**ä¿®å¤å»ºè®®**:
```python
def linear_ackermann_model(self, nom_st, nom_ut, dt, L):
    phi = nom_st[2, 0]
    v, psi = nom_ut[0, 0], nom_ut[1, 0]
    
    # å®‰å…¨é™åˆ¶è½¬å‘è§’
    psi_safe = torch.clamp(psi, min=-1.5, max=1.5)  # é™åˆ¶åœ¨ Â±1.5 rad
    cos_psi = torch.cos(psi_safe)
    
    # é¿å…é™¤é›¶ï¼šå¦‚æœ cos(psi) å¤ªå°ï¼Œä½¿ç”¨æœ€å°å€¼
    cos_psi_sq = cos_psi ** 2
    cos_psi_sq = torch.clamp(cos_psi_sq, min=1e-4)  # é˜²æ­¢é™¤é›¶
    
    A = torch.Tensor([ [1, 0, -v * dt * sin(phi)], 
                       [0, 1, v * dt * cos(phi)], 
                       [0, 0, 1] ])
    
    B = torch.Tensor([ [cos(phi)*dt, 0], 
                       [sin(phi)*dt, 0], 
                       [ tan(psi_safe)*dt / L, v*dt/(L * cos_psi_sq) ] ])
    
    C = torch.Tensor([ [ phi*v*sin(phi)*dt ], 
                       [ -phi*v*cos(phi)*dt ], 
                       [ -psi_safe * v*dt / ( L * cos_psi_sq) ]])
    
    return to_device(A), to_device(B), to_device(C)
```

---

### 2. æ•°ç»„è¶Šç•Œé£é™© - ROI é™é‡‡æ ·

**ä½ç½®**: `neupan/blocks/roi_selector.py:159-160, 178-179`  
**ä¸¥é‡ç¨‹åº¦**: ğŸ”´ **é«˜**  
**é—®é¢˜ç±»å‹**: æ½œåœ¨å´©æºƒ

**é—®é¢˜ä»£ç **:
```python
# Line 159-160
ds_local = np.linspace(0, n_roi - 1, m, dtype=int)
sel_idx = sel_idx[ds_local]  # å¦‚æœ ds_local è¶…å‡º sel_idx èŒƒå›´ä¼šè¶Šç•Œ
```

**é—®é¢˜åˆ†æ**:
- `np.linspace(0, n_roi - 1, m)` ç”Ÿæˆçš„ç´¢å¼•å¯èƒ½è¶…å‡º `sel_idx` çš„å®é™…é•¿åº¦
- å½“ `n_roi` è®¡ç®—é”™è¯¯æˆ– `sel_idx` è¢«ä¿®æ”¹æ—¶ï¼Œä¼šè§¦å‘ IndexError
- åœ¨ Line 178-179 æœ‰ç›¸åŒé—®é¢˜

**å½±å“èŒƒå›´**:
- ROI è¿‡æ»¤å¤±è´¥ï¼Œè§„åˆ’å™¨å´©æºƒ
- åœ¨ç‚¹äº‘ç¨€ç–åœºæ™¯ä¸‹é«˜æ¦‚ç‡è§¦å‘

**ä¿®å¤å»ºè®®**:
```python
if n_roi > self.cfg.guardrail_n_max:
    m = int(self.cfg.guardrail_n_max)
    # å®‰å…¨æ£€æŸ¥ï¼šç¡®ä¿ m ä¸è¶…è¿‡å®é™…ç‚¹æ•°
    m = min(m, len(sel_idx))
    if m > 0:
        ds_local = np.linspace(0, len(sel_idx) - 1, m, dtype=int)
        sel_idx = sel_idx[ds_local]
        pts_roi = pts[:, sel_idx]
        n_roi = pts_roi.shape[1]
```

---

### 3. çŠ¶æ€æ•°ç»„å½¢çŠ¶ä¸ä¸€è‡´ - neupan.py

**ä½ç½®**: `neupan/neupan.py:260-262`  
**ä¸¥é‡ç¨‹åº¦**: ğŸ”´ **é«˜**  
**é—®é¢˜ç±»å‹**: æ½œåœ¨å´©æºƒ

**é—®é¢˜ä»£ç **:
```python
robot_xy = state[:2, :]  # (2, 1) current position
heading_rad = float(state[2, 0])  # å‡è®¾ state æ˜¯ (3, 1)
```

**é—®é¢˜åˆ†æ**:
- å¦‚æœ `state` æ˜¯ `(3,)` è€Œä¸æ˜¯ `(3, 1)`ï¼Œ`state[2, 0]` ä¼šæŠ›å‡º IndexError
- `forward()` æ–¹æ³•åªæ£€æŸ¥ `state.shape[0] >= 3`ï¼Œä¸æ£€æŸ¥ç»´åº¦æ•°

**å½±å“èŒƒå›´**:
- è§„åˆ’å™¨åˆå§‹åŒ–å¤±è´¥
- åœ¨æŸäº›ç¯å¢ƒä¸‹æ— æ³•å¯åŠ¨

**ä¿®å¤å»ºè®®**:
```python
def _apply_roi(self, points: np.ndarray, nom_input_np: list, state: np.ndarray) -> np.ndarray:
    # è§„èŒƒåŒ– state å½¢çŠ¶
    if state.ndim == 1:
        state = state.reshape(-1, 1)
    if state.shape[0] < 3 or state.shape[1] < 1:
        raise ValueError(f"Invalid state shape: {state.shape}, expected (3, 1)")
    
    robot_xy = state[:2, :]
    heading_rad = float(state[2, 0])
    # ...
```

---

### 4. ç‚¹äº‘é€Ÿåº¦æ•°ç»„å¯¹é½é”™è¯¯

**ä½ç½®**: `neupan/neupan.py:190-195`  
**ä¸¥é‡ç¨‹åº¦**: ğŸŸ¡ **ä¸­**  
**é—®é¢˜ç±»å‹**: é€»è¾‘é”™è¯¯

**é—®é¢˜ä»£ç **:
```python
if velocities is not None and roi_indices is not None:
    try:
        if velocities.shape[1] >= int(np.max(roi_indices)) + 1:
            velocities = velocities[:, roi_indices]
    except Exception:
        velocities = None
```

**é—®é¢˜åˆ†æ**:
- å¦‚æœ `roi_indices` åŒ…å«é‡å¤ç´¢å¼•æˆ–ä¹±åºç´¢å¼•ï¼Œé€Ÿåº¦å¯¹é½ä¼šå‡ºé”™
- `np.max(roi_indices)` åªæ£€æŸ¥æœ€å¤§å€¼ï¼Œä¸æ£€æŸ¥æ‰€æœ‰ç´¢å¼•æ˜¯å¦æœ‰æ•ˆ
- å¼‚å¸¸å¤„ç†è¿‡äºå®½æ³›ï¼Œéšè—äº†çœŸæ­£çš„é—®é¢˜

**ä¿®å¤å»ºè®®**:
```python
if velocities is not None and roi_indices is not None:
    try:
        # æ£€æŸ¥æ‰€æœ‰ç´¢å¼•æ˜¯å¦æœ‰æ•ˆ
        if velocities.shape[1] > 0 and len(roi_indices) > 0:
            max_idx = int(np.max(roi_indices))
            if max_idx < velocities.shape[1]:
                velocities = velocities[:, roi_indices]
            else:
                print(f"Warning: ROI indices out of range (max={max_idx}, vel_cols={velocities.shape[1]})")
                velocities = None
    except (IndexError, ValueError) as e:
        print(f"Warning: Failed to align velocities with ROI: {e}")
        velocities = None
```

---

### 5. æ— é™å¾ªç¯é£é™© - ROI Guardrail

**ä½ç½®**: `neupan/blocks/roi_selector.py:141-173`  
**ä¸¥é‡ç¨‹åº¦**: ğŸŸ¡ **ä¸­**  
**é—®é¢˜ç±»å‹**: é€»è¾‘ç¼ºé™·

**é—®é¢˜ä»£ç **:
```python
if n_roi < self.cfg.guardrail_n_min:
    # Too few points, relax parameters and retry
    self._relax_parameters()
    # Retry with relaxed parameters
    mask = self._reachability_cone_mask(inputs)
    # ...
    # åªå°è¯•ä¸€æ¬¡ relaxï¼Œå¦‚æœè¿˜ä¸å¤Ÿæ€ä¹ˆåŠï¼Ÿ
```

**é—®é¢˜åˆ†æ**:
- å½“å‰ä»£ç åªå°è¯•ä¸€æ¬¡ relax
- å¦‚æœç¯å¢ƒä¸­éšœç¢ç‚¹æå°‘ï¼ˆå¦‚ < 5 ä¸ªï¼‰ï¼Œå³ä½¿ relax åä»å¯èƒ½ä¸æ»¡è¶³ `n_min`
- è™½ç„¶æœ‰ fallback é€»è¾‘ï¼Œä½†ä¸å¤Ÿæ˜ç¡®

**ä¿®å¤å»ºè®®**:
```python
# æ·»åŠ æœ€å¤§ relax æ¬¡æ•°é™åˆ¶
max_relax_attempts = 3
for attempt in range(max_relax_attempts):
    if n_roi >= self.cfg.guardrail_n_min:
        break
    self._relax_parameters()
    mask = self._reachability_cone_mask(inputs)
    mask = self._apply_always_keep(inputs, mask)
    sel_idx = np.flatnonzero(mask)
    pts_roi = pts[:, sel_idx]
    n_roi = pts_roi.shape[1]

# å¦‚æœä»ç„¶ä¸å¤Ÿï¼Œä½¿ç”¨ fallback
if n_roi < self.cfg.guardrail_n_min:
    # Fallback: return all points
    pass
```

---

## ğŸŸ¡ åŠŸèƒ½æ€§Bugï¼ˆä¸­ä¼˜å…ˆçº§ï¼‰

### 6. å­—å…¸é”®ç¼ºå¤±å¯¼è‡´ AttributeError

**ä½ç½®**: `neupan/neupan.py:103-114`  
**ä¸¥é‡ç¨‹åº¦**: ğŸŸ¡ **ä¸­**  
**é—®é¢˜ç±»å‹**: å¼‚å¸¸å¤„ç†ä¸è¶³

**é—®é¢˜ä»£ç **:
```python
cone_fov_base_deg=roi_kwargs.get("cone", {}).get("fov_base_deg", 90.0),
```

**é—®é¢˜åˆ†æ**:
- å¦‚æœ `roi_kwargs["cone"]` æ˜¯ `None` è€Œä¸æ˜¯å­—å…¸ï¼Œ`.get()` ä¼šæŠ›å‡º AttributeError
- é…ç½®æ–‡ä»¶æ ¼å¼é”™è¯¯æ—¶ä¼šå´©æºƒ

**ä¿®å¤å»ºè®®**:
```python
def safe_nested_get(d, *keys, default=None):
    """å®‰å…¨åœ°ä»åµŒå¥—å­—å…¸ä¸­è·å–å€¼"""
    for key in keys:
        if not isinstance(d, dict):
            return default
        d = d.get(key, {})
    return d if d != {} else default

# ä½¿ç”¨ç¤ºä¾‹
cone_fov_base_deg = safe_nested_get(roi_kwargs, "cone", "fov_base_deg", default=90.0)
```

---

### 7. ç‚¹äº‘é™é‡‡æ ·ç´¢å¼•é”™è¯¯ - pan.py

**ä½ç½®**: `neupan/blocks/pan.py:166-169`  
**ä¸¥é‡ç¨‹åº¦**: ğŸŸ¡ **ä¸­**  
**é—®é¢˜ç±»å‹**: æ•°æ®ä¸ä¸€è‡´

**é—®é¢˜ä»£ç **:
```python
if obs_points.shape[1] > self.dune_max_num:
    self.print_once(f"down sample the obs points from {obs_points.shape[1]} to {self.dune_max_num}") 
    obs_points = downsample_decimation(obs_points, self.dune_max_num)
    point_velocities = downsample_decimation(point_velocities, self.dune_max_num)
```

**é—®é¢˜åˆ†æ**:
- å¦‚æœ `point_velocities` çš„åˆ—æ•°ä¸ `obs_points` ä¸ä¸€è‡´ï¼Œé™é‡‡æ ·åä¼šä¸åŒ¹é…
- æ²¡æœ‰æ£€æŸ¥ `point_velocities` æ˜¯å¦ä¸º None

**ä¿®å¤å»ºè®®**:
```python
if obs_points.shape[1] > self.dune_max_num:
    self.print_once(f"down sample the obs points from {obs_points.shape[1]} to {self.dune_max_num}") 
    obs_points = downsample_decimation(obs_points, self.dune_max_num)
    if point_velocities is not None and point_velocities.shape[1] == obs_points.shape[1]:
        point_velocities = downsample_decimation(point_velocities, self.dune_max_num)
```

---

### 8. å¼‚å¸¸å¤„ç†è¿‡äºå®½æ³› - batch_core_modules_evaluation.py

**ä½ç½®**: `test/batch_core_modules_evaluation.py:276-286, 298-299`  
**ä¸¥é‡ç¨‹åº¦**: ğŸŸ¡ **ä¸­**  
**é—®é¢˜ç±»å‹**: ä»£ç è´¨é‡

**é—®é¢˜ä»£ç **:
```python
try:
    md = float(getattr(planner, 'min_distance', 0.0))
    min_d_list.append(md)
except Exception:
    pass  # åæ‰æ‰€æœ‰å¼‚å¸¸
```

**é—®é¢˜åˆ†æ**:
- ä½¿ç”¨ `except Exception: pass` ä¼šéšè—æ‰€æœ‰é”™è¯¯
- éš¾ä»¥è°ƒè¯•é—®é¢˜

**ä¿®å¤å»ºè®®**:
```python
try:
    md = float(getattr(planner, 'min_distance', 0.0))
    min_d_list.append(md)
except (AttributeError, TypeError, ValueError) as e:
    if not quiet:
        print(f"Warning: Failed to get min_distance: {e}")
```

---

## ğŸŸ¢ ä»£ç è´¨é‡é—®é¢˜

### 9. é‡å¤çš„ None æ£€æŸ¥ - pan.py

**ä½ç½®**: `neupan/blocks/pan.py:163, 176`  
**ä¸¥é‡ç¨‹åº¦**: ğŸŸ¢ **ä½**  
**é—®é¢˜ç±»å‹**: ä»£ç é‡å¤

**é—®é¢˜ä»£ç **:
```python
# Line 163
if point_velocities is None:
    point_velocities = torch.zeros_like(obs_points)

# Line 176 (é‡å¤æ£€æŸ¥)
if point_velocities is None:
    point_velocities = torch.zeros_like(obs_points)
```

**ä¿®å¤å»ºè®®**:
åˆ é™¤ç¬¬äºŒä¸ªæ£€æŸ¥ï¼ˆLine 176-177ï¼‰

---

### 10. ç¡¬ç¼–ç çš„é­”æ³•æ•°å­—

**ä½ç½®**: å¤šå¤„  
**ä¸¥é‡ç¨‹åº¦**: ğŸŸ¢ **ä½**  
**é—®é¢˜ç±»å‹**: å¯ç»´æŠ¤æ€§

**ç¤ºä¾‹**:
- `roi_selector.py:272`: `v_max = 8.0` (ç¡¬ç¼–ç æœ€å¤§é€Ÿåº¦)
- `roi_selector.py:277`: `T_horizon = 1.0` (ç¡¬ç¼–ç æ—¶é—´èŒƒå›´)
- `roi_selector.py:281`: `r_vehicle = 1.3` (ç¡¬ç¼–ç è½¦è¾†åŠå¾„)

**ä¿®å¤å»ºè®®**:
å°†è¿™äº›å€¼æå–ä¸ºé…ç½®å‚æ•°æˆ–ç±»å¸¸é‡

---

## ğŸ’¡ ä¼˜åŒ–å»ºè®®

### 11. æ€§èƒ½ä¼˜åŒ– - ROI æ›²ç‡è®¡ç®—

**ä½ç½®**: `neupan/blocks/roi_selector.py:294-310`  
**é—®é¢˜**: å¾ªç¯è®¡ç®—æ›²ç‡æ•ˆç‡ä½

**ä¼˜åŒ–å»ºè®®**:
```python
# å‘é‡åŒ–è®¡ç®—
if path is not None and path.shape[1] >= 3:
    v1 = path[:, 1:-1] - path[:, :-2]  # (2, T-1)
    v2 = path[:, 2:] - path[:, 1:-1]   # (2, T-1)
    
    norm1 = np.linalg.norm(v1, axis=0)  # (T-1,)
    norm2 = np.linalg.norm(v2, axis=0)  # (T-1,)
    
    valid = (norm1 > 1e-6) & (norm2 > 1e-6)
    
    angles = np.arctan2(v2[1], v2[0]) - np.arctan2(v1[1], v1[0])
    angles = np.arctan2(np.sin(angles), np.cos(angles))
    
    kappa_max = np.max(np.abs(angles[valid])) if np.any(valid) else 0.0
```

---

### 12. å†…å­˜ä¼˜åŒ– - é¿å…é‡å¤åˆ›å»º Tensor

**ä½ç½®**: `neupan/robot/robot.py:262-268`  
**é—®é¢˜**: æ¯æ¬¡è°ƒç”¨éƒ½åˆ›å»ºæ–°çš„ Tensor

**ä¼˜åŒ–å»ºè®®**:
ç¼“å­˜å¸¸ç”¨çš„çŸ©é˜µæ¨¡æ¿ï¼Œåªæ›´æ–°æ•°å€¼

---

## ğŸ“Š é—®é¢˜ç»Ÿè®¡

| ä¸¥é‡ç¨‹åº¦ | æ•°é‡ | ç±»å‹åˆ†å¸ƒ |
|---------|------|---------|
| ğŸ”´ æé«˜ | 1 | é™¤é›¶é”™è¯¯ |
| ğŸ”´ é«˜ | 4 | æ•°ç»„è¶Šç•Œ(1), å½¢çŠ¶ä¸ä¸€è‡´(1), é€Ÿåº¦å¯¹é½(1), æ— é™å¾ªç¯(1) |
| ğŸŸ¡ ä¸­ | 3 | å­—å…¸é”®ç¼ºå¤±(1), é™é‡‡æ ·é”™è¯¯(1), å¼‚å¸¸å¤„ç†(1) |
| ğŸŸ¢ ä½ | 2 | ä»£ç é‡å¤(1), é­”æ³•æ•°å­—(1) |
| ğŸ’¡ ä¼˜åŒ– | 2 | æ€§èƒ½ä¼˜åŒ–(1), å†…å­˜ä¼˜åŒ–(1) |

**æ€»è®¡**: 12 ä¸ªé—®é¢˜

---

## âœ… ä»£ç ä¼˜ç‚¹

1. **æ¶æ„æ¸…æ™°**: PAN â†’ DUNE + NRMP åˆ†å±‚è®¾è®¡åˆç†
2. **é”™è¯¯å¤„ç†**: å¤§éƒ¨åˆ†å…³é”®è·¯å¾„æœ‰ try-except ä¿æŠ¤
3. **æ–‡æ¡£å®Œå–„**: å‡½æ•°æ³¨é‡Šå’Œç±»å‹æç¤ºè¾ƒå®Œæ•´
4. **å¯é…ç½®æ€§**: YAML é…ç½®ç³»ç»Ÿçµæ´»
5. **æµ‹è¯•è¦†ç›–**: æ‰¹é‡æµ‹è¯•è„šæœ¬åŠŸèƒ½å®Œå–„

---

## ğŸ¯ ä¿®å¤ä¼˜å…ˆçº§å»ºè®®

### ç«‹å³ä¿®å¤ï¼ˆæœ¬å‘¨å†…ï¼‰
1. âœ… é™¤é›¶é”™è¯¯ (robot.py:265) - **æé«˜ä¼˜å…ˆçº§**
2. âœ… æ•°ç»„è¶Šç•Œ (roi_selector.py:159, 178)
3. âœ… çŠ¶æ€å½¢çŠ¶æ£€æŸ¥ (neupan.py:260)

### å°½å¿«ä¿®å¤ï¼ˆ2å‘¨å†…ï¼‰
4. é€Ÿåº¦æ•°ç»„å¯¹é½ (neupan.py:190)
5. ROI Guardrail é€»è¾‘ (roi_selector.py:141)
6. å­—å…¸é”®å®‰å…¨è®¿é—® (neupan.py:103)

### è®¡åˆ’ä¿®å¤ï¼ˆ1ä¸ªæœˆå†…ï¼‰
7. å¼‚å¸¸å¤„ç†æ”¹è¿› (batch_core_modules_evaluation.py)
8. ä»£ç é‡å¤æ¸…ç†
9. æ€§èƒ½ä¼˜åŒ–

---

## ğŸ“ æ€»ä½“è¯„ä»·

**ä»£ç è´¨é‡**: â­â­â­â­ (4/5)

**ä¼˜ç‚¹**:
- æ¶æ„è®¾è®¡åˆç†ï¼Œæ¨¡å—åŒ–è‰¯å¥½
- æ ¸å¿ƒç®—æ³•å®ç°æ­£ç¡®
- é…ç½®ç³»ç»Ÿçµæ´»

**éœ€æ”¹è¿›**:
- è¾¹ç•Œæ¡ä»¶æ£€æŸ¥ä¸è¶³ï¼ˆé™¤é›¶ã€æ•°ç»„è¶Šç•Œï¼‰
- å¼‚å¸¸å¤„ç†è¿‡äºå®½æ³›
- éƒ¨åˆ†ç¡¬ç¼–ç å€¼éœ€è¦é…ç½®åŒ–

**å»ºè®®**:
1. æ·»åŠ å•å…ƒæµ‹è¯•è¦†ç›–è¾¹ç•Œæƒ…å†µ
2. ä½¿ç”¨é™æ€ç±»å‹æ£€æŸ¥å·¥å…·ï¼ˆmypyï¼‰
3. æ·»åŠ è¾“å…¥éªŒè¯è£…é¥°å™¨
4. å»ºç«‹ CI/CD æµç¨‹

---

**æŠ¥å‘Šç”Ÿæˆæ—¶é—´**: 2025-10-23  
**å®¡æŸ¥äºº**: AI Code Reviewer  
**ä¸‹ä¸€æ¬¡å®¡æŸ¥**: ä¿®å¤åé‡æ–°å®¡æŸ¥

