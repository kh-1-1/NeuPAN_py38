# 对偶可行性违反率计算方法

## 目录
1. [基本概念](#基本概念)
2. [计算方法](#计算方法)
3. [代码实现](#代码实现)
4. [评估指标体系](#评估指标体系)
5. [实际应用](#实际应用)

---

## 一、基本概念

### 对偶可行域定义

在DUNE模块中,对偶变量 μ 需要满足:

```
可行域 C = {μ ∈ R^E | μ ≥ 0, ||G^T μ||_2 ≤ 1}
```

其中:
- `μ`: 对偶权重向量 `[E, N]` (E=边数, N=点数)
- `G`: 机器人几何矩阵 `[E, 2]`
- `||·||_2`: L2范数

### 违反的定义

对于每个点 i,其对偶权重 μ_i 违反约束当且仅当:

```
||G^T μ_i||_2 > 1.0
```

---

## 二、计算方法

### 方法1: 硬阈值违反率 (NeuPAN当前实现) ⭐

**定义**:
```
violation_rate = (1/N) * Σ I(||G^T μ_i||_2 > 1.0)
```

其中 `I(·)` 是指示函数 (条件为真时=1,否则=0)

**PyTorch实现**:
```python
v = G.T @ mu  # [2, N]
norms = torch.norm(v, dim=0)  # [N]
violation_rate = (norms > 1.0).float().mean().item()
```

**优点**:
- ✅ 简单直观
- ✅ 计算高效
- ✅ 易于解释

**缺点**:
- ⚠️ 对阈值敏感 (1.0 vs 1.0001)
- ⚠️ 不反映违反程度

---

### 方法2: 软违反率 (带容差)

**定义**:
```
violation_rate(τ) = (1/N) * Σ I(||G^T μ_i||_2 > 1.0 + τ)
```

其中 `τ` 是容差 (如 `1e-6`)

**PyTorch实现**:
```python
tolerance = 1e-6
v = G.T @ mu
norms = torch.norm(v, dim=0)
violation_rate = (norms > 1.0 + tolerance).float().mean().item()
```

**优点**:
- ✅ 考虑浮点数精度
- ✅ 更鲁棒

**适用场景**:
- 评估硬投影效果
- 论文中报告指标

---

### 方法3: 加权违反率 (按违反程度)

**定义**:
```
weighted_violation = (1/N) * Σ max(0, ||G^T μ_i||_2 - 1.0)
```

**PyTorch实现**:
```python
v = G.T @ mu
norms = torch.norm(v, dim=0)
weighted_violation = torch.clamp(norms - 1.0, min=0.0).mean().item()
```

**优点**:
- ✅ 反映违反程度
- ✅ 可微分 (可用于损失函数)

**缺点**:
- ⚠️ 单位不直观 (不是百分比)

---

### 方法4: 相对违反率

**定义**:
```
relative_violation = (1/N) * Σ max(0, (||G^T μ_i||_2 - 1.0) / 1.0)
```

**PyTorch实现**:
```python
v = G.T @ mu
norms = torch.norm(v, dim=0)
relative_violation = torch.clamp((norms - 1.0) / 1.0, min=0.0).mean().item()
```

**优点**:
- ✅ 归一化,易于比较
- ✅ 反映相对违反程度

---

### 方法5: 分层违反率

**定义**: 统计不同违反程度的比例

```python
def layered_violation_rate(mu, G):
    v = G.T @ mu
    norms = torch.norm(v, dim=0)
    
    return {
        'mild': (norms > 1.0) & (norms <= 1.01),      # 轻微违反
        'moderate': (norms > 1.01) & (norms <= 1.05), # 中等违反
        'severe': (norms > 1.05),                     # 严重违反
    }
```

**优点**:
- ✅ 细粒度分析
- ✅ 便于诊断

---

## 三、代码实现

### 完整的违反率计算类

```python
import torch
import numpy as np

class DualFeasibilityMetrics:
    """对偶可行性评估指标"""
    
    def __init__(self, G, tolerance=1e-6):
        """
        Args:
            G: 机器人几何矩阵 [E, 2]
            tolerance: 浮点数容差
        """
        self.G = G
        self.tolerance = tolerance
    
    def compute_all_metrics(self, mu):
        """
        计算所有违反率指标
        
        Args:
            mu: 对偶权重 [E, N]
        
        Returns:
            dict: 包含所有指标的字典
        """
        v = self.G.T @ mu  # [2, N]
        norms = torch.norm(v, dim=0)  # [N]
        
        metrics = {}
        
        # 1. 硬阈值违反率
        metrics['violation_rate_hard'] = (norms > 1.0).float().mean().item()
        
        # 2. 软违反率 (带容差)
        metrics['violation_rate_soft'] = (
            norms > 1.0 + self.tolerance
        ).float().mean().item()
        
        # 3. 加权违反率
        metrics['weighted_violation'] = (
            torch.clamp(norms - 1.0, min=0.0).mean().item()
        )
        
        # 4. 相对违反率
        metrics['relative_violation'] = (
            torch.clamp((norms - 1.0) / 1.0, min=0.0).mean().item()
        )
        
        # 5. 最大违反
        metrics['max_violation'] = (norms - 1.0).max().item()
        
        # 6. 百分位数
        if norms.numel() > 0:
            metrics['p50_norm'] = torch.quantile(norms, 0.50).item()
            metrics['p95_norm'] = torch.quantile(norms, 0.95).item()
            metrics['p99_norm'] = torch.quantile(norms, 0.99).item()
        
        # 7. 分层违反率
        metrics['mild_violation_rate'] = (
            (norms > 1.0) & (norms <= 1.01)
        ).float().mean().item()
        metrics['moderate_violation_rate'] = (
            (norms > 1.01) & (norms <= 1.05)
        ).float().mean().item()
        metrics['severe_violation_rate'] = (
            norms > 1.05
        ).float().mean().item()
        
        # 8. 统计信息
        metrics['mean_norm'] = norms.mean().item()
        metrics['std_norm'] = norms.std().item()
        metrics['min_norm'] = norms.min().item()
        metrics['max_norm'] = norms.max().item()
        
        return metrics
    
    def print_report(self, mu, name=''):
        """打印详细报告"""
        metrics = self.compute_all_metrics(mu)
        
        print(f"\n{'='*60}")
        print(f"Dual Feasibility Report {name}")
        print(f"{'='*60}")
        
        print(f"\n基本统计:")
        print(f"  点数: {mu.shape[1]}")
        print(f"  平均范数: {metrics['mean_norm']:.6f}")
        print(f"  标准差: {metrics['std_norm']:.6f}")
        print(f"  范围: [{metrics['min_norm']:.6f}, {metrics['max_norm']:.6f}]")
        
        print(f"\n违反率:")
        print(f"  硬阈值 (>1.0): {metrics['violation_rate_hard']:.2%}")
        print(f"  软阈值 (>1.0+{self.tolerance}): {metrics['violation_rate_soft']:.2%}")
        print(f"  加权违反: {metrics['weighted_violation']:.6f}")
        print(f"  相对违反: {metrics['relative_violation']:.2%}")
        
        print(f"\n百分位数:")
        print(f"  P50: {metrics['p50_norm']:.6f}")
        print(f"  P95: {metrics['p95_norm']:.6f}")
        print(f"  P99: {metrics['p99_norm']:.6f}")
        
        print(f"\n分层违反:")
        print(f"  轻微 (1.0-1.01): {metrics['mild_violation_rate']:.2%}")
        print(f"  中等 (1.01-1.05): {metrics['moderate_violation_rate']:.2%}")
        print(f"  严重 (>1.05): {metrics['severe_violation_rate']:.2%}")
        
        print(f"\n最大违反:")
        print(f"  幅度: {metrics['max_violation']:.6f}")
        if metrics['max_violation'] > 0:
            print(f"  相对: {metrics['max_violation'] / 1.0 * 100:.2f}%")
        
        print(f"\n{'='*60}\n")
        
        return metrics
```

---

## 四、评估指标体系

### 推荐的指标组合

#### 1. 论文报告指标

```python
# 主要指标
- violation_rate_soft (带容差)
- p95_norm
- max_violation

# 示例
print(f"Violation rate: {violation_rate_soft:.2%}")
print(f"P95 norm: {p95_norm:.4f}")
print(f"Max violation: {max_violation:.2e}")
```

#### 2. 调试诊断指标

```python
# 详细分析
- violation_rate_hard
- weighted_violation
- 分层违反率
- 统计分布

# 用于定位问题
if severe_violation_rate > 0.01:
    print("⚠️ 存在严重违反,需要检查投影逻辑")
```

#### 3. 训练监控指标

```python
# 实时监控
- violation_rate_soft (每个epoch)
- p95_norm (趋势)
- max_violation (异常检测)

# TensorBoard记录
writer.add_scalar('dual/violation_rate', violation_rate_soft, epoch)
writer.add_scalar('dual/p95_norm', p95_norm, epoch)
```

---

## 五、实际应用

### 应用1: 在DUNE中集成

修改 `neupan/blocks/dune.py`:

```python
class DUNE(torch.nn.Module):
    def __init__(self, ...):
        # ... 现有代码
        
        # 新增: 违反率计算器
        from neupan.evaluation.dual_metrics import DualFeasibilityMetrics
        self.dual_metrics = DualFeasibilityMetrics(self.G, tolerance=1e-6)
    
    def forward(self, point_flow, R_list, obs_points_list=[]):
        # ... 现有代码到第90行
        
        with torch.no_grad():
            total_mu = self.model(total_points.T).T
            
            # 投影前评估
            if self.monitor_dual_norm:
                pre_metrics = self.dual_metrics.compute_all_metrics(total_mu)
                self.dual_norm_violation_rate = pre_metrics['violation_rate_soft']
                self.dual_norm_p95 = pre_metrics['p95_norm']
                self.dual_norm_max_violation = pre_metrics['max_violation']
            
            # 硬投影
            if self.projection == 'hard':
                # ... 投影代码
                
                # 投影后验证
                post_metrics = self.dual_metrics.compute_all_metrics(total_mu)
                self.dual_norm_violation_rate_post = post_metrics['violation_rate_soft']
                
                # 断言 (调试模式)
                if self.training and post_metrics['violation_rate_soft'] > 0.01:
                    print(f"⚠️ 投影后仍有 {post_metrics['violation_rate_soft']:.2%} 违反")
```

---

### 应用2: 在训练中监控

修改 `neupan/blocks/dune_train.py`:

```python
class DUNETrain:
    def train_one_epoch(self, train_dataloader, validate=False):
        # ... 现有代码
        
        # 累积违反率统计
        total_violation = 0
        total_p95 = 0
        
        for input_point, label_mu, label_distance in train_dataloader:
            # ... 前向传播
            
            # 计算违反率
            v = self.G.T @ output_mu.squeeze(2).T
            norms = torch.norm(v, dim=0)
            violation_rate = (norms > 1.0 + 1e-6).float().mean().item()
            p95 = torch.quantile(norms, 0.95).item()
            
            total_violation += violation_rate
            total_p95 += p95
        
        # 平均违反率
        avg_violation = total_violation / len(train_dataloader)
        avg_p95 = total_p95 / len(train_dataloader)
        
        return mu_loss, distance_loss, fa_loss, fb_loss, avg_violation, avg_p95
```

---

### 应用3: 在评测中使用

创建 `neupan/evaluation/dual_metrics.py`:

```python
import torch

class DualFeasibilityMetrics:
    """完整的对偶可行性评估工具"""
    
    # ... (前面定义的完整类)
    
    def compare_methods(self, mu_dict):
        """
        对比多个方法的违反率
        
        Args:
            mu_dict: {method_name: mu_tensor}
        
        Returns:
            DataFrame: 对比表格
        """
        import pandas as pd
        
        results = []
        for name, mu in mu_dict.items():
            metrics = self.compute_all_metrics(mu)
            results.append({
                'Method': name,
                'Violation Rate': f"{metrics['violation_rate_soft']:.2%}",
                'P95 Norm': f"{metrics['p95_norm']:.4f}",
                'Max Violation': f"{metrics['max_violation']:.2e}",
                'Weighted Violation': f"{metrics['weighted_violation']:.4f}",
            })
        
        return pd.DataFrame(results)
```

使用示例:

```python
# 对比baseline vs DF-DUNE
metrics = DualFeasibilityMetrics(G, tolerance=1e-6)

mu_dict = {
    'Baseline': mu_baseline,
    'Hard Projection': mu_hard_proj,
    'PDHG (J=3)': mu_pdhg,
    'DF-DUNE': mu_df_dune,
}

comparison = metrics.compare_methods(mu_dict)
print(comparison)

# 输出:
#          Method  Violation Rate  P95 Norm  Max Violation  Weighted Violation
# 0      Baseline           10.5%    1.0123       2.34e-02              0.0045
# 1  Hard Projection        0.0%    0.9998       1.19e-07              0.0000
# 2     PDHG (J=3)          0.0%    0.9995       5.96e-08              0.0000
# 3      DF-DUNE            0.0%    0.9992       2.98e-08              0.0000
```

---

## 六、最佳实践建议

### 1. 选择合适的指标

| 场景 | 推荐指标 | 原因 |
|------|---------|------|
| 论文报告 | `violation_rate_soft` + `p95_norm` | 鲁棒,易解释 |
| 训练监控 | `violation_rate_soft` + `max_violation` | 实时,异常检测 |
| 调试诊断 | 分层违反率 + 统计分布 | 细粒度分析 |
| 方法对比 | `violation_rate_soft` + `weighted_violation` | 全面,可比 |

### 2. 设置合理的容差

```python
# 单精度浮点数
tolerance = 1e-6  # 推荐

# 双精度浮点数
tolerance = 1e-12

# 实际应用 (考虑累积误差)
tolerance = 1e-5
```

### 3. 可视化违反分布

```python
import matplotlib.pyplot as plt

def plot_violation_distribution(mu, G):
    v = G.T @ mu
    norms = torch.norm(v, dim=0).cpu().numpy()
    
    plt.figure(figsize=(10, 6))
    plt.hist(norms, bins=50, alpha=0.7, edgecolor='black')
    plt.axvline(1.0, color='red', linestyle='--', label='Threshold')
    plt.xlabel('||G^T μ||_2')
    plt.ylabel('Frequency')
    plt.title('Dual Norm Distribution')
    plt.legend()
    plt.grid(True, alpha=0.3)
    plt.show()
```

---

## 七、总结

### 推荐的计算流程

```python
# 1. 计算对偶范数
v = G.T @ mu
norms = torch.norm(v, dim=0)

# 2. 硬阈值违反率 (快速检查)
violation_rate_hard = (norms > 1.0).float().mean().item()

# 3. 软阈值违反率 (论文报告)
violation_rate_soft = (norms > 1.0 + 1e-6).float().mean().item()

# 4. 百分位数 (分布特征)
p95_norm = torch.quantile(norms, 0.95).item()

# 5. 最大违反 (异常检测)
max_violation = (norms - 1.0).max().item()
```

### 关键要点

1. ✅ **使用软阈值** (`1.0 + tolerance`) 避免浮点数精度问题
2. ✅ **报告多个指标** (违反率 + P95 + 最大违反)
3. ✅ **可视化分布** 便于诊断
4. ✅ **对比投影前后** 验证改进效果

---

**相关文件**:
- 实现: `neupan/blocks/dune.py:103-107`
- 评测: `neupan/evaluation/dual_metrics.py` (待创建)
- 测试: `test/test_projection_ab_synthetic.py`

