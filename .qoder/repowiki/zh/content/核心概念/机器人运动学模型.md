# 机器人运动学模型

<cite>
**本文档中引用的文件**
- [robot.py](file://neupan/robot/robot.py)
- [pan.py](file://neupan/blocks/pan.py)
- [initial_path.py](file://neupan/blocks/initial_path.py)
</cite>

## 目录
1. [引言](#引言)
2. [差速驱动与阿克曼转向模型](#差速驱动与阿克曼转向模型)
3. [状态转移矩阵的线性化差异](#状态转移矩阵的线性化差异)
4. [机器人几何形状与碰撞检测](#机器人几何形状与碰撞检测)
5. [物理限制与优化约束](#物理限制与优化约束)
6. [坐标变换在点云处理中的作用](#坐标变换在点云处理中的作用)
7. [自定义机器人参数配置](#自定义机器人参数配置)
8. [结论](#结论)

## 引言
NeuPAN 是一种基于模型预测控制（MPC）的路径规划算法，支持多种机器人运动学模型。本文重点介绍其支持的两种核心运动学模型：差速驱动（diff）和阿克曼转向（acker）。我们将深入分析它们在状态转移建模、雅可比线性化策略、几何约束处理以及物理边界条件方面的实现机制，并结合代码结构说明关键方法的设计原理。

## 差速驱动与阿克曼转向模型
NeuPAN 通过 `robot` 类的 `kinematics` 参数区分两种运动学模型。差速驱动模型适用于两轮独立驱动的机器人，其运动由线速度和角速度控制；阿克曼转向模型则模拟汽车式转向，其前轮可转向，运动由线速度和前轮转向角控制。

在 `initial_path.py` 中，`ackermann_model` 和 `diff_model` 方法分别实现了非线性状态转移函数，用于预测下一时刻的机器人状态：
- **阿克曼模型**：状态更新依赖于转向角 `psi` 和轮距 `wheel_base`。
- **差速模型**：状态更新直接使用角速度 `w`。

**Section sources**
- [initial_path.py](file://neupan/blocks/initial_path.py#L394-L448)

## 状态转移矩阵的线性化差异
为了在优化问题中处理非线性动力学，NeuPAN 采用雅可比线性化方法，在名义轨迹附近对动力学方程进行近似，生成状态转移矩阵 A、B 和偏移项 C。

### linear_diff_model 与 linear_ackermann_model 的对比
| 特性 | linear_diff_model | linear_ackermann_model |
|------|-------------------|------------------------|
| **转向角处理** | 无转向角，角速度 `w` 直接作为控制输入 | 转向角 `psi` 作为控制输入，需通过 `tan(psi)` 和 `cos(psi)` 计算 |
| **B 矩阵 (控制输入影响)** | 第三行第二列为 `dt`，表示角速度对航向角的直接影响 | 第三行第一列为 `tan(psi)*dt / L`，第二列为 `v*dt/(L * (cos(psi))**2)`，体现速度和转向角的耦合效应 |
| **C 矩阵 (非线性偏移)** | 仅与当前航向角 `phi` 和速度 `v` 相关 | 额外包含与转向角 `psi` 相关的项 `-psi * v*dt / ( L * (cos(psi))**2)` |
| **雅可比线性化策略** | 相对简单，角速度项线性 | 更复杂，涉及 `tan` 和 `sec^2` 函数，对转向角变化更敏感 |

这种差异反映了两种模型在物理行为上的根本区别：差速模型的转向是直接的，而阿克曼模型的转向通过前轮偏转实现，存在几何约束。

**Section sources**
- [robot.py](file://neupan/robot/robot.py#L256-L286)

## 机器人几何形状与碰撞检测
机器人的物理尺寸通过 `vertices`（顶点）定义，这些顶点用于构建碰撞检测所需的不等式约束。

### 顶点与 G/h 不等式约束
1.  **顶点生成**：`cal_vertices` 方法根据用户提供的 `vertices` 或 `length`、`width`、`wheelbase` 参数生成机器人的轮廓顶点。
2.  **不等式约束生成**：调用 `gen_inequal_from_vertex` 函数，将凸多边形的顶点转换为标准的线性不等式形式 `Gx <= h`。其中：
    - `G` 是一个 `(n, 2)` 的矩阵，每一行代表多边形一条边的法向量。
    - `h` 是一个 `(n, 1)` 的向量，代表原点到各边的距离。
    - `x` 是待检测的点坐标。
    这些 `G` 和 `h` 被存储在 `robot` 实例中，用于后续的优化问题，确保机器人在运动过程中其轮廓不与障碍物相交。

**Section sources**
- [robot.py](file://neupan/robot/robot.py#L36-L72)
- [robot.py](file://neupan/robot/robot.py#L308-L348)

## 物理限制与优化约束
机器人的物理特性（如最大速度、最大加速度）被直接转化为优化问题中的边界约束。

### 约束的实现
在 `robot` 类的 `__init__` 方法中：
- `max_speed` 和 `max_acce` 参数被接收并存储。
- 在 `bound_su_constraints` 方法中，这些参数被用于构建 `cvxpy` 约束：
    - `cp.abs(self.indep_u) <= self.speed_bound`：限制控制输入（速度）的绝对值不超过 `max_speed`。
    - `cp.abs(self.indep_u[:, 1:] - self.indep_u[:, :-1]) <= self.acce_bound`：限制相邻时刻控制输入的变化率（即加速度），其中 `acce_bound` 是 `max_acce * dt`。

对于阿克曼模型，代码还包含一个安全检查：若 `max_speed[1]`（最大转向角）超过 1.57 弧度（约 90 度），会自动将其限制在 1.57 弧度，以防止数值不稳定。

**Section sources**
- [robot.py](file://neupan/robot/robot.py#L36-L72)
- [robot.py](file://neupan/robot/robot.py#L190-L237)

## 坐标变换在点云处理中的作用
`PAN` 类的 `generate_point_flow` 方法是处理动态环境的关键，它利用机器人坐标系变换来高效处理点云数据。

### generate_point_flow 方法流程
1.  **时间展开**：对于预测时域 `T+1` 中的每一个时刻 `i`，根据障碍物的初始位置 `obs_points` 和速度 `point_velocities`，预测其在 `i*dt` 时刻的位置。
2.  **坐标变换**：调用 `point_state_transform` 方法，将全局坐标系下的障碍物点云转换到机器人在该时刻的局部坐标系下。
    - **核心操作**：`p0 = R.T @ (obs_points - trans)`
    - `trans` 是机器人在该时刻的位置 `[x, y]`。
    - `R` 是由机器人航向角 `theta` 构成的旋转矩阵。
    - 此变换消除了机器人的平移和旋转，使得障碍物相对于机器人的运动被“冻结”，从而简化了后续的避障决策。
3.  **输出**：返回一个列表，包含每个预测时刻的局部点云、旋转矩阵和全局点云，供 `DUNE` 和 `NRMP` 模块使用。

这种变换使得避障策略可以基于“机器人看到什么”来制定，而不是复杂的全局运动学计算。

```mermaid
flowchart TD
A[全局障碍物点云] --> B{预测时域循环}
B --> C[预测障碍物未来位置]
C --> D[获取机器人名义状态]
D --> E[计算平移向量 trans]
E --> F[计算旋转矩阵 R]
F --> G[坐标变换: p0 = R.T @ (obs_points - trans)]
G --> H[局部点云 p0]
H --> I[存储到 point_flow_list]
B --> J[输出: point_flow_list, R_list, obs_points_list]
```

**Diagram sources**
- [pan.py](file://neupan/blocks/pan.py#L27-L271)

**Section sources**
- [pan.py](file://neupan/blocks/pan.py#L27-L271)

## 自定义机器人参数配置
用户可以通过 `robot` 类的构造函数灵活配置机器人参数。

### 配置示例
```python
# 创建一个差速驱动机器人
diff_robot = robot(
    kinematics='diff',
    length=0.6,      # 长度 0.6 米
    width=0.4,       # 宽度 0.4 米
    max_speed=[2.0, 1.0],  # 最大线速度 2.0 m/s, 最大角速度 1.0 rad/s
    max_acce=[1.0, 0.5],   # 最大线加速度 1.0 m/s², 最大角加速度 0.5 rad/s²
    receding=15,     # 预测时域 15 步
    step_time=0.1    # 时间步长 0.1 秒
)

# 创建一个阿克曼转向机器人
acker_robot = robot(
    kinematics='acker',
    length=4.0,      # 长度 4.0 米
    width=1.8,       # 宽度 1.8 米
    wheelbase=2.7,   # 轴距 2.7 米
    max_speed=[15.0, 0.5], # 最大线速度 15.0 m/s, 最大转向角 0.5 rad
    max_acce=[2.0, 0.3]    # 最大线加速度 2.0 m/s², 最大转向角加速度 0.3 rad/s²
)
```

### wheelbase 参数对阿克曼模型精度的影响
`wheelbase`（轴距）是阿克曼模型的核心参数，它直接影响状态转移方程的精度：
- **在 `linear_ackermann_model` 中**：`B` 矩阵和 `C` 矩阵的元素都包含 `1/L` 项。一个准确的 `wheelbase` 值能确保雅可比矩阵正确反映转向角变化对机器人航向角变化率的影响。
- **影响**：如果 `wheelbase` 设置不准确，会导致模型预测的转弯半径与实际机器人不符。例如，设置过大的 `wheelbase` 会使模型预测的转弯更平缓（转弯半径更大），可能导致规划出的路径在实际执行时发生碰撞。

因此，为阿克曼机器人提供精确的 `wheelbase` 值对于保证规划精度和安全性至关重要。

**Section sources**
- [robot.py](file://neupan/robot/robot.py#L36-L72)

## 结论
NeuPAN 通过精心设计的 `robot` 类，灵活支持差速驱动和阿克曼转向两种主流运动学模型。其核心在于利用雅可比线性化将非线性动力学转化为优化问题中的线性约束，并通过 `vertices` 和 `G/h` 不等式精确建模机器人几何形状以实现碰撞检测。物理限制被直接编码为优化变量的边界约束。`PAN` 类中的 `generate_point_flow` 方法通过坐标系变换，将复杂的动态避障问题简化为机器人局部视角下的处理，极大地提升了算法的效率和鲁棒性。用户可以通过配置 `length`、`width`、`wheelbase`、`max_speed` 等参数来适配不同类型的机器人，其中 `wheelbase` 的准确性对阿克曼模型的性能尤为关键。