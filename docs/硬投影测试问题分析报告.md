# ç¡¬æŠ•å½±æµ‹è¯•é—®é¢˜åˆ†ææŠ¥å‘Š

## é—®é¢˜æ€»ç»“

**æµ‹è¯•ç»“æœ**: `projection=hard` æ—¶ `post-proj max_norm = 1.0000001192092896`ï¼Œç•¥å¾®è¶…è¿‡1.0

**ç»“è®º**: âœ… **è¿™æ˜¯æ­£å¸¸çš„æµ®ç‚¹æ•°ç²¾åº¦è¯¯å·®ï¼Œç¡¬æŠ•å½±åŠŸèƒ½å·¥ä½œæ­£å¸¸**

---

## è¯¦ç»†åˆ†æ

### 1. ç¡¬æŠ•å½±ä»£ç é€»è¾‘éªŒè¯ âœ… æ­£ç¡®

**ä»£ç ä½ç½®**: `neupan/blocks/dune.py:109-119`

```python
if self.projection == 'hard':
    # clamp mu >= 0
    total_mu.clamp_(min=0.0)
    # project columns to satisfy ||G^T mu||_2 <= 1
    v = (self.G.T @ total_mu)                    # [2, N]
    v_norm = torch.norm(v, dim=0, keepdim=True)  # [1, N]
    mask = (v_norm > 1.0).float()                # 1 if >1, else 0
    denom = v_norm.clamp(min=1.0)                # max(v_norm, 1.0)
    scale = mask / denom + (1.0 - mask)          # v_norm>1: 1/v_norm, else: 1
    total_mu = total_mu * scale                  # ç¼©æ”¾åˆ°å•ä½çƒå†…
```

**é€»è¾‘éªŒè¯**:
- âœ… å½“ `||v|| > 1` æ—¶: `scale = 1/||v||`ï¼Œç¼©æ”¾å `||v_new|| = 1`
- âœ… å½“ `||v|| â‰¤ 1` æ—¶: `scale = 1`ï¼Œä¿æŒä¸å˜
- âœ… æŠ•å½±åç†è®ºä¸Šåº”æ»¡è¶³ `||G^T Î¼|| â‰¤ 1`

---

### 2. æµ‹è¯•ä»£ç ä¸­çš„è®¡ç®—è·¯å¾„åˆ†æ âš ï¸ å…³é”®å‘ç°

**æµ‹è¯•ä»£ç ** (`test/test_projection_ab_synthetic.py:50-55`):

```python
post_max_norm = 0.0
for lam in lam_list:
    if lam is None or lam.numel() == 0:
        continue
    # Since R is orthonormal, ||lam|| = ||G^T mu|| after projection
    post_max_norm = max(post_max_norm, torch.norm(lam, dim=0).max().item())
```

**è®¡ç®—è·¯å¾„**:
```
Î¼ (æŠ•å½±å) â†’ G^T @ Î¼ â†’ R @ (G^T @ Î¼) â†’ Î» = -R @ (G^T @ Î¼)
                â†‘                              â†‘
            åº”è¯¥ â‰¤1                    æµ‹è¯•è¿™é‡Œçš„èŒƒæ•°
```

**å…³é”®é—®é¢˜**: æµ‹è¯•ä»£ç é€šè¿‡ `||Î»||` æ¥éªŒè¯ `||G^T Î¼||`ï¼Œä¾èµ–äºå‡è®¾ **Ræ˜¯æ­£äº¤çŸ©é˜µ**ã€‚

---

### 3. RçŸ©é˜µçš„ç”Ÿæˆä¸æ­£äº¤æ€§éªŒè¯ ğŸ” æ ¸å¿ƒé—®é¢˜

**RçŸ©é˜µç”Ÿæˆä»£ç ** (`neupan/blocks/pan.py:206`):

```python
theta = state[2, 0]
R = torch.tensor([[torch.cos(theta), -torch.sin(theta)], 
                  [torch.sin(theta), torch.cos(theta)]])
```

**ç†è®ºä¸Š**: è¿™æ˜¯æ ‡å‡†çš„2Dæ—‹è½¬çŸ©é˜µï¼Œåº”è¯¥æ»¡è¶³ `R^T @ R = I`ï¼Œå³ `||R @ v|| = ||v||`

**ä½†æ˜¯**: å­˜åœ¨ä»¥ä¸‹æ½œåœ¨è¯¯å·®æº:

#### 3.1 æµ®ç‚¹æ•°ç²¾åº¦è¯¯å·®

**è¯¯å·®æ¥æº**:
1. `torch.cos(theta)` å’Œ `torch.sin(theta)` çš„è®¡ç®—ç²¾åº¦
2. çŸ©é˜µä¹˜æ³• `R @ (G^T @ Î¼)` çš„ç´¯ç§¯è¯¯å·®
3. èŒƒæ•°è®¡ç®— `torch.norm(lam, dim=0)` çš„èˆå…¥è¯¯å·®

**éªŒè¯**: è®©æˆ‘ä»¬è®¡ç®—ç†è®ºè¯¯å·®ä¸Šç•Œ

```python
# å•ç²¾åº¦æµ®ç‚¹æ•° (float32)
epsilon = 1.19209e-07  # machine epsilon

# è¯¯å·®ä¼ æ’­:
# 1. cos/sin è®¡ç®—: ~epsilon
# 2. çŸ©é˜µä¹˜æ³• (2x2 @ 2xN): ~2*epsilon per element
# 3. èŒƒæ•°è®¡ç®— (sqrt(x^2 + y^2)): ~epsilon

# æ€»è¯¯å·®: O(10 * epsilon) â‰ˆ 1e-6
```

**å®é™…è§‚æµ‹è¯¯å·®**: `1.0000001192092896 - 1.0 = 1.192e-07` âœ… **åœ¨é¢„æœŸèŒƒå›´å†…**

#### 3.2 æµ‹è¯•åœºæ™¯ä¸­çš„thetaå€¼

**æµ‹è¯•ä»£ç ** (`test/test_projection_ab_synthetic.py:39`):

```python
nom_s = to_device(torch.zeros(3, 11))  # [x, y, theta] å…¨ä¸º0
```

**å…³é”®å‘ç°**: `theta = 0`ï¼Œæ­¤æ—¶:
```python
R = [[cos(0), -sin(0)],     [[1.0, 0.0],
     [sin(0),  cos(0)]]  =   [0.0, 1.0]]
```

**ç†è®ºä¸Š**: `R = I` (å•ä½çŸ©é˜µ)ï¼Œåº”è¯¥ `||R @ v|| = ||v||` **ç²¾ç¡®æˆç«‹**

**ä½†å®é™…**: `cos(0)` å’Œ `sin(0)` åœ¨æµ®ç‚¹æ•°è¡¨ç¤ºä¸‹å¯èƒ½ä¸æ˜¯ç²¾ç¡®çš„1.0å’Œ0.0

---

### 4. æ•°å€¼éªŒè¯å®éªŒ

è®©æˆ‘ä»¬æ‰‹åŠ¨éªŒè¯æŠ•å½±é€»è¾‘:

```python
import torch

# æ¨¡æ‹Ÿåœºæ™¯
G = torch.randn(4, 2)  # æœºå™¨äººå‡ ä½•çŸ©é˜µ
mu = torch.randn(4, 100)  # åŸå§‹å¯¹å¶æƒé‡

# ç¡¬æŠ•å½±
v = G.T @ mu
v_norm = torch.norm(v, dim=0, keepdim=True)
mask = (v_norm > 1.0).float()
denom = v_norm.clamp(min=1.0)
scale = mask / denom + (1.0 - mask)
mu_proj = mu * scale

# éªŒè¯
v_proj = G.T @ mu_proj
v_proj_norm = torch.norm(v_proj, dim=0)

print(f"Max norm after projection: {v_proj_norm.max().item()}")
print(f"Expected: â‰¤ 1.0")
print(f"Violation: {(v_proj_norm > 1.0).sum().item()} / {v_proj_norm.numel()}")
```

**é¢„æœŸç»“æœ**: `max_norm â‰ˆ 1.0 + O(1e-7)`

---

### 5. æ ¹æœ¬åŸå› æ€»ç»“

#### ä¸»è¦åŸå› : **æµ®ç‚¹æ•°ç²¾åº¦é™åˆ¶** âœ…

1. **æŠ•å½±ç®—æ³•æœ¬èº«æ­£ç¡®**: ä»£ç é€»è¾‘å®Œå…¨ç¬¦åˆæ•°å­¦å®šä¹‰
2. **è¯¯å·®æ¥æº**: 
   - çŸ©é˜µä¹˜æ³•çš„èˆå…¥è¯¯å·®
   - èŒƒæ•°è®¡ç®—çš„èˆå…¥è¯¯å·®
   - é™¤æ³•è¿ç®— `1/v_norm` çš„ç²¾åº¦æŸå¤±
3. **è¯¯å·®é‡çº§**: `1.192e-07` æ˜¯å•ç²¾åº¦æµ®ç‚¹æ•°çš„**æœºå™¨ç²¾åº¦**é‡çº§

#### æ¬¡è¦å› ç´ : **æµ‹è¯•æ–¹æ³•çš„é—´æ¥æ€§** âš ï¸

æµ‹è¯•ä»£ç é€šè¿‡ `||Î»|| = ||R @ G^T @ Î¼||` æ¥éªŒè¯ `||G^T @ Î¼||`ï¼Œå¼•å…¥äº†é¢å¤–çš„è®¡ç®—æ­¥éª¤:
- RçŸ©é˜µçš„æ„é€ è¯¯å·®
- é¢å¤–çš„çŸ©é˜µä¹˜æ³•è¯¯å·®

**æ›´ç›´æ¥çš„æµ‹è¯•æ–¹æ³•**:
```python
# ç›´æ¥éªŒè¯ ||G^T @ Î¼|| è€Œä¸æ˜¯é€šè¿‡ Î»
v_post = dl.G.T @ total_mu  # ç›´æ¥è®¿é—®æŠ•å½±åçš„ Î¼
post_max_norm = torch.norm(v_post, dim=0).max().item()
```

---

## ç»“è®ºä¸å»ºè®®

### âœ… ç¡¬æŠ•å½±åŠŸèƒ½æ­£å¸¸

**è¯æ®**:
1. æŠ•å½±ä»£ç é€»è¾‘æ­£ç¡®
2. è§‚æµ‹è¯¯å·® `1.192e-07` åœ¨æµ®ç‚¹æ•°ç²¾åº¦èŒƒå›´å†…
3. `projection=none` çš„ç»“æœ `1.0205967` æ˜¾è‘—å¤§äº `projection=hard` çš„ `1.0000001`

### ğŸ“Š å¯¹æ¯”æ•°æ®

| é…ç½® | post_max_norm | ä¸1.0çš„å·®è· | è¯„ä¼° |
|------|--------------|------------|------|
| `projection=hard` | 1.0000001192 | **+1.19e-07** | âœ… æµ®ç‚¹æ•°ç²¾åº¦å†… |
| `projection=none` | 1.0205967426 | **+2.06e-02** | âš ï¸ æ˜¾è‘—è¿åçº¦æŸ |

**æ”¹è¿›å¹…åº¦**: ç¡¬æŠ•å½±å°†è¿åå¹…åº¦ä» **2%** é™è‡³ **0.00001%**

---

## å»ºè®®çš„æ”¹è¿›æªæ–½

### 1. æ”¾å®½æµ‹è¯•å®¹å·® (æ¨è) â­

```python
# test/test_projection_ab_synthetic.py
TOLERANCE = 1e-6  # å•ç²¾åº¦æµ®ç‚¹æ•°çš„åˆç†å®¹å·®

print('\nExpectation:')
print(f'- With projection=hard, post-proj max_norm should be <= 1.0 + {TOLERANCE}')
print(f'- With projection=none, post-proj max_norm may be > 1.0')

# éªŒè¯
if proj == 'hard':
    assert post_mx <= 1.0 + TOLERANCE, f"Hard projection failed: {post_mx} > 1.0 + {TOLERANCE}"
    print(f'  âœ… PASS: {post_mx} <= 1.0 + {TOLERANCE}')
```

### 2. ç›´æ¥éªŒè¯ G^T @ Î¼ (æ¨è) â­â­

ä¿®æ”¹æµ‹è¯•ä»£ç ï¼Œç›´æ¥è®¿é—®æŠ•å½±åçš„ `Î¼`:

```python
# åœ¨ DUNE.forward ä¸­æš´éœ² total_mu (è°ƒè¯•ç”¨)
# æˆ–è€…åœ¨æµ‹è¯•ä¸­ç›´æ¥è°ƒç”¨æŠ•å½±é€»è¾‘

def run_once(projection: str = 'hard', n_points: int = 512, seed: int = 0):
    # ... ç°æœ‰ä»£ç 
    
    # ç›´æ¥éªŒè¯ (éœ€è¦è®¿é—® total_mu)
    # æ–¹æ³•1: ä¿®æ”¹ DUNE æš´éœ² total_mu
    # æ–¹æ³•2: é‡æ–°å®ç°æŠ•å½±é€»è¾‘è¿›è¡ŒéªŒè¯
    
    # é—´æ¥éªŒè¯ (å½“å‰æ–¹æ³•)
    post_max_norm_via_lam = ...
    
    # ç›´æ¥éªŒè¯ (æ–°å¢)
    if hasattr(dl, '_debug_total_mu'):
        v_direct = dl.G.T @ dl._debug_total_mu
        post_max_norm_direct = torch.norm(v_direct, dim=0).max().item()
        print(f'  post-proj max_norm (direct): {post_max_norm_direct}')
```

### 3. ä½¿ç”¨åŒç²¾åº¦æµ®ç‚¹æ•° (å¯é€‰)

å¦‚æœéœ€è¦æ›´é«˜ç²¾åº¦:

```python
# åœ¨ DUNE.__init__ ä¸­
self.G = self.G.double()
self.h = self.h.double()
self.model = self.model.double()
```

**æƒè¡¡**: 
- âœ… ç²¾åº¦æå‡è‡³ `~1e-15`
- âš ï¸ è®¡ç®—é€Ÿåº¦é™ä½ ~2å€
- âš ï¸ å†…å­˜å ç”¨å¢åŠ  2å€

### 4. å¢å¼ºæŠ•å½±ç®—æ³•çš„æ•°å€¼ç¨³å®šæ€§ (é«˜çº§)

```python
if self.projection == 'hard':
    total_mu.clamp_(min=0.0)
    v = (self.G.T @ total_mu)
    v_norm = torch.norm(v, dim=0, keepdim=True)
    
    # åŸå§‹ç‰ˆæœ¬
    # scale = torch.where(v_norm > 1.0, 1.0 / v_norm, torch.ones_like(v_norm))
    
    # æ•°å€¼ç¨³å®šç‰ˆæœ¬: é¿å…é™¤æ³•ï¼Œä½¿ç”¨ä¹˜æ³•
    eps = 1e-8  # é˜²æ­¢é™¤é›¶
    scale = torch.where(
        v_norm > 1.0, 
        1.0 / (v_norm + eps),  # åŠ  eps æé«˜ç¨³å®šæ€§
        torch.ones_like(v_norm)
    )
    total_mu = total_mu * scale
    
    # å¯é€‰: äºŒæ¬¡æŠ•å½±ç¡®ä¿ä¸¥æ ¼æ»¡è¶³çº¦æŸ
    v_check = (self.G.T @ total_mu)
    v_check_norm = torch.norm(v_check, dim=0, keepdim=True)
    if (v_check_norm > 1.0 + 1e-6).any():
        # å†æ¬¡æŠ•å½±
        scale2 = torch.where(v_check_norm > 1.0, 1.0 / v_check_norm, torch.ones_like(v_check_norm))
        total_mu = total_mu * scale2
```

---

## æµ‹è¯•è„šæœ¬æ”¹è¿›å»ºè®®

### å®Œæ•´çš„æ”¹è¿›ç‰ˆæµ‹è¯•ä»£ç 

```python
# test/test_projection_ab_synthetic.py (æ”¹è¿›ç‰ˆ)

import torch
import numpy as np
from neupan.blocks.pan import PAN
from neupan.robot.robot import robot as Robot
from neupan.configuration import to_device
import os

TOLERANCE = 1e-6  # æµ®ç‚¹æ•°å®¹å·®

def run_once(projection: str = 'hard', n_points: int = 512, seed: int = 0):
    torch.manual_seed(seed)
    np.random.seed(seed)

    rob = Robot(kinematics='acker', length=4.6, width=1.6, wheelbase=3)
    ckpt = 'example/model/acker_robot_default/model_5000.pth'
    has_ckpt = os.path.exists(ckpt)

    pan = PAN(
        receding=10,
        step_time=0.2,
        robot=rob,
        dune_max_num=n_points,
        nrmp_max_num=10,
        dune_checkpoint=ckpt if has_ckpt else None,
        adjust_kwargs=dict(eta=15.0, d_max=1.0, d_min=0.1),
        train_kwargs=dict(
            projection=projection,
            monitor_dual_norm=True,
            unroll_J=0,
            se2_embed=False,
            direct_train=not has_ckpt,
        ),
    )

    obs = to_device(torch.randn(2, n_points) * 10.0)
    nom_s = to_device(torch.zeros(3, 11))

    pf, Rl, opl = pan.generate_point_flow(nom_s, obs)
    mu_list, lam_list, _ = pan.dune_layer(pf, Rl, opl)

    dl = pan.dune_layer
    pre_violation = getattr(dl, 'dual_norm_violation_rate', None)
    pre_p95 = getattr(dl, 'dual_norm_p95', None)

    # æ–¹æ³•1: é€šè¿‡ Î» é—´æ¥éªŒè¯ (ç°æœ‰æ–¹æ³•)
    post_max_norm_via_lam = 0.0
    for lam in lam_list:
        if lam is None or lam.numel() == 0:
            continue
        post_max_norm_via_lam = max(post_max_norm_via_lam, torch.norm(lam, dim=0).max().item())

    # æ–¹æ³•2: ç›´æ¥éªŒè¯ G^T @ Î¼ (æ–°å¢)
    post_max_norm_direct = 0.0
    for mu in mu_list:
        if mu is None or mu.numel() == 0:
            continue
        v = dl.G.T @ mu
        post_max_norm_direct = max(post_max_norm_direct, torch.norm(v, dim=0).max().item())

    return pre_violation, pre_p95, post_max_norm_via_lam, post_max_norm_direct


def main():
    print('Synthetic A/B test for DUNE projection')
    print(f'Tolerance: {TOLERANCE}\n')

    results = {}
    for proj in ['hard', 'none']:
        pre_v, pre_p95, post_lam, post_direct = run_once(projection=proj, n_points=512, seed=0)
        results[proj] = (pre_v, pre_p95, post_lam, post_direct)
        
        print(f'projection={proj}')
        print(f'  pre-proj violation_rate: {pre_v}')
        print(f'  pre-proj dual_norm_p95: {pre_p95}')
        print(f'  post-proj max_norm (via lam): {post_lam}')
        print(f'  post-proj max_norm (direct): {post_direct}')
        
        # éªŒè¯
        if proj == 'hard':
            if post_direct <= 1.0 + TOLERANCE:
                print(f'  âœ… PASS: {post_direct:.10f} <= 1.0 + {TOLERANCE}')
            else:
                print(f'  âŒ FAIL: {post_direct:.10f} > 1.0 + {TOLERANCE}')
        print()

    # å¯¹æ¯”åˆ†æ
    print('Comparison:')
    hard_direct = results['hard'][3]
    none_direct = results['none'][3]
    improvement = (none_direct - hard_direct) / none_direct * 100
    print(f'  Hard projection reduces max_norm by {improvement:.2f}%')
    print(f'  From {none_direct:.6f} to {hard_direct:.10f}')


if __name__ == '__main__':
    main()
```

---

## æœ€ç»ˆç»“è®º

### âœ… ç¡¬æŠ•å½±åŠŸèƒ½å®Œå…¨æ­£å¸¸

**ç†ç”±**:
1. **ä»£ç é€»è¾‘æ­£ç¡®**: æŠ•å½±ç®—æ³•ç¬¦åˆæ•°å­¦å®šä¹‰
2. **è¯¯å·®å¯æ¥å—**: `1.192e-07` æ˜¯æµ®ç‚¹æ•°ç²¾åº¦çš„å¿…ç„¶ç»“æœ
3. **æ•ˆæœæ˜¾è‘—**: å°†è¿åå¹…åº¦ä»2%é™è‡³0.00001%

### ğŸ“ å»ºè®®è¡ŒåŠ¨

1. **ç«‹å³**: åœ¨æµ‹è¯•ä¸­æ·»åŠ  `TOLERANCE = 1e-6` å®¹å·®
2. **çŸ­æœŸ**: å®ç°ç›´æ¥éªŒè¯æ–¹æ³• (è®¿é—® `G^T @ Î¼`)
3. **é•¿æœŸ**: è€ƒè™‘åœ¨è®ºæ–‡ä¸­è¯´æ˜æ•°å€¼ç²¾åº¦å¤„ç†

### ğŸ¯ å¯¹DF-DUNEæ–¹æ¡ˆçš„å¯ç¤º

è¿™ä¸ªåˆ†æéªŒè¯äº†:
- âœ… ç¡¬æŠ•å½±åŸºç¡€è®¾æ–½å·²å°±ç»ªä¸”å·¥ä½œæ­£å¸¸
- âœ… å¯ä»¥ç›´æ¥åœ¨æ­¤åŸºç¡€ä¸Šæ·»åŠ KKTæ­£åˆ™å’ŒPDHGå±•å¼€
- âš ï¸ éœ€è¦æ³¨æ„æµ®ç‚¹æ•°ç²¾åº¦åœ¨è¯„æµ‹ä¸­çš„å½±å“

**å»ºè®®**: åœ¨å®æ–½DF-DUNEæ—¶ï¼Œæ‰€æœ‰çº¦æŸéªŒè¯éƒ½åº”ä½¿ç”¨åˆç†çš„å®¹å·® (å¦‚ `1e-6`)

